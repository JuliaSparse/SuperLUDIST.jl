var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = SuperLUDIST","category":"page"},{"location":"#SuperLUDIST","page":"Home","title":"SuperLUDIST","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SuperLUDIST.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [SuperLUDIST]","category":"page"},{"location":"#SuperLUDIST.DistributedSuperMatrix","page":"Home","title":"SuperLUDIST.DistributedSuperMatrix","text":"mutable struct DistributedSuperMatrix{T, I, S, F, J, G} <: SuperLUDIST.AbstractSuperMatrix{T, I, S}\n\nSuperMatrix distributed by row between all ranks in a communicator. The Julia representation may be accessed by A.store::SparseBase.CSRStore{T, CIndex{<:Int}}.\n\nEach local matrix stores a subset of rows specified by A.globalrows\n\nExtended\n\nsupermatrix\nInternal: Reference to Common.SuperMatrix{I}\nformat\nInternal: Reference to storage format Common.NRFormat_loc{I} held by supermatrix\nstore\nJulia-side storage, of type SparseBase.CSRStore. Keeps memory alive.\nglobalsize\nfirst_row\ngrid\n\n\n\n\n\n","category":"type"},{"location":"#SuperLUDIST.DistributedSuperMatrix-Union{Tuple{SuperLUDIST.Grid{Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Home","title":"SuperLUDIST.DistributedSuperMatrix","text":"DistributedSuperMatrix{Tv, Ti}()\n\nConstruct an empty DistributedSuperMatrix to be filled later.\n\nNote: Currently, modifying Julia-level fields will not propagate to the C structs. For instance in order to update the size you must update the size of     A::DistributedSuperMatrix.store as well as the sizes stored in A.format and     A.supermatrix.\n\n\n\n\n\n","category":"method"},{"location":"#SuperLUDIST.DistributedSuperMatrix-Union{Tuple{Ti}, Tuple{Any, Any, Any, Any, Any, Any, SuperLUDIST.Grid{Ti}}} where Ti","page":"Home","title":"SuperLUDIST.DistributedSuperMatrix","text":"DistributedSuperMatrix(rowptr, colidx, v, firstrow, localsize, globalsize, grid::SuperLUDIST.Grid{Ti}) -> DistributedSuperMatrix\n\n\nConstruct a DistributedSuperMatrix from the vectors of a CSR matrix, and the necessary metadata.\n\nValid index types are {Int32, Int64}, or CIndex{Int32}, CIndex{Int64}, if the indices are already 0-based. Valid element types are {Float32, Float64, ComplexF64}.\n\nArguments\n\nrowptr, colidx, v : sparse storage vectors, must be valid CSR matrix internals with types noted above.\nfirstrow : the 1-based starting row of the matrix on this rank.\nlocalsize : the local size of the matrix on this rank.\nglobalsize : the size of the matrix across all ranks.\ngrid : the grid on which the matrix is distributed.\n\n\n\n\n\n","category":"method"},{"location":"#SuperLUDIST.DistributedSuperMatrix-Union{Tuple{Ti}, Tuple{SparseBase.SinglyCompressedStore{<:Any, StorageOrders.RowMajor(), CIndices.CIndex{Ti}}, Any, Any, SuperLUDIST.Grid{Ti}}} where Ti","page":"Home","title":"SuperLUDIST.DistributedSuperMatrix","text":"DistributedSuperMatrix(A::SparseBase.SinglyCompressedStore{<:Any, StorageOrders.RowMajor(), CIndices.CIndex{Ti}}, firstrow, globalsize, grid::SuperLUDIST.Grid{Ti}) -> DistributedSuperMatrix\n\n\nConstruct a DistributedSuperMatrix from a finished SparseBase.CSRStore.\n\nArguments\n\nA : sparse storage in CSR form, valid index types are {Int32, Int64}, valid element types are {Float32, Float64, ComplexF64}.\nfirstrow : the 1-based starting row of A on this rank.\nglobalsize : the size of A across all ranks.\n\n\n\n\n\n","category":"method"},{"location":"#SuperLUDIST.DistributedSuperMatrix-Union{Tuple{Ti}, Tuple{Tuple{var\"#s19670\", var\"#s19670\"} where var\"#s19670\"<:(AbstractVector), Any, Any, Any, Any, SuperLUDIST.Grid{Ti}}} where Ti","page":"Home","title":"SuperLUDIST.DistributedSuperMatrix","text":"DistributedSuperMatrix(::Tuple{var\"#s19670\", var\"#s19670\"} where var\"#s19670\"<:(AbstractVector), v, firstrow, localsize, globalsize, grid::SuperLUDIST.Grid{Ti}) -> DistributedSuperMatrix\n\n\nConstruct a DistributedSuperMatrix from COO format and the necessary metadata.\n\nValid index types are {Int32, Int64}, or CIndex{Int32}, CIndex{Int64}, if the indices are already 0-based. Valid element types are {Float32, Float64, ComplexF64}.\n\nArguments\n\n(rows, cols), v : sparse storage vectors, must be valid COO matrix internals with types noted above.\nfirstrow : the 1-based starting row of the matrix on this rank.\nlocalsize : the local size of the matrix on this rank.\nglobalsize : the size of the matrix across all ranks.\ngrid : the grid on which the matrix is distributed.\n\n\n\n\n\n","category":"method"},{"location":"#SuperLUDIST.ReplicatedSuperMatrix","page":"Home","title":"SuperLUDIST.ReplicatedSuperMatrix","text":"mutable struct ReplicatedSuperMatrix{T, I, S, F, J, G} <: SuperLUDIST.AbstractSuperMatrix{T, I, S}\n\nSuperMatrix that has been globally replicated on all ranks in a communicator. The local storage contains the full matrix, the Julia representation may be accessed by A.store::SparseBase.CSCStore{T, CIndex{<:Int}}.\n\nExtended\n\nsupermatrix\nInternal: Reference to Common.SuperMatrix{I}\nformat\nInternal: Reference to storage format Common.NCformat{I} held by supermatrix\nstore\nJulia-side storage, of type SparseBase.CSCStore. Keeps memory alive.\ngrid\n\n\n\n\n\n","category":"type"},{"location":"#MatrixMarket.mmread-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{<:DistributedSuperMatrix{Tv, Ti}}, Any, SuperLUDIST.Grid{Ti}}} where {Tv<:Union{Float32, Float64, ComplexF64}, Ti<:Union{Int32, Int64}}","page":"Home","title":"MatrixMarket.mmread","text":"mmread(DistributedSuperMatrix{Tv, Ti}, filename::String, partitioner = distribute_evenly)\n\nRead an mtx file into a compressed sparse column format and broadcast it to all ranks in comm.\n\nTo read an mtx file locally use mmread(SparseBase.CSCStore...).\n\nArguments\n\narg1<:Type{ReplicatedSuperMatrix{Tv, Ti}}\nTv <: Union{Float32, Float64, ComplexF64}: Non-optional eltype.\nTi <: Union{Int32, Int64}: Non-optional index type.\nfilename::String: .mtx file accessible by the root process.\n\nKeyword Arguments\n\ndesymmetrize::Bool = true: If the matrix file is represented\n\nin symmetric form, represent in the full form.\n\nroot::Int = 0: The MPI process on which to read the file.\ncomm::MPI.Comm = MPI.COMM_WORLD: The MPI communicator on which to distribute\n\nthe matrix.\n\nExample\n\nusing MPI, SuperLUDIST, MatrixMarket\nA = MatrixMarket.mmread(ReplicatedSuperMatrix{Float64, Int32}, )\n\n\n\n\n\n","category":"method"},{"location":"#MatrixMarket.mmread-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{<:ReplicatedSuperMatrix{Tv, Ti}}, Any, SuperLUDIST.Grid{Ti}}} where {Tv<:Union{Float32, Float64, ComplexF64}, Ti<:Union{Int32, Int64}}","page":"Home","title":"MatrixMarket.mmread","text":"mmread(ReplicatedSuperMatrix{Tv, Ti}, filename::String)\n\nRead an mtx file into a compressed sparse column format and broadcast it to all ranks in comm.\n\nTo read an mtx file locally use mmread(SparseBase.CSCStore...).\n\nArguments\n\narg1<:Type{ReplicatedSuperMatrix{Tv, Ti}}\nTv <: Union{Float32, Float64, ComplexF64}: Non-optional eltype.\nTi <: Union{Int32, Int64}: Non-optional index type.\nfilename::String: .mtx file accessible by the root process.\n\nKeyword Arguments\n\ndesymmetrize::Bool = true: If the matrix file is represented\n\nin symmetric form, represent in the full form.\n\nroot::Int = 0: The MPI process on which to read the file.\ncomm::MPI.Comm = MPI.COMM_WORLD: The MPI communicator on which to distribute\n\nthe matrix.\n\nExample\n\nusing MPI, SuperLUDIST, MatrixMarket\nA = MatrixMarket.mmread(ReplicatedSuperMatrix{Float64, Int32}, )\n\n\n\n\n\n","category":"method"},{"location":"#SparseBase.Communication.scatterstore!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{DistributedSuperMatrix{Tv, Ti}, Union{Nothing, SparseBase.SinglyCompressedStore{Tvalues, StorageOrders.RowMajor()} where Tvalues}, Any}} where {Tv, Ti}","page":"Home","title":"SparseBase.Communication.scatterstore!","text":"scatterstore!(rstore::DistributedSuperMatrix{Tv, Ti}, sstore::Union{Nothing, SparseBase.SinglyCompressedStore{Tvalues, StorageOrders.RowMajor()} where Tvalues}, chunksizes) -> DistributedSuperMatrix\n\n\n\n\n\n\n","category":"method"},{"location":"#SuperLUDIST.pgssvx!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{DistributedSuperMatrix{Tv, Ti}, VecOrMat{Tv}}} where {Tv, Ti}","page":"Home","title":"SuperLUDIST.pgssvx!","text":"pgssvx!(A::DistributedSuperMatrix{Tv, Ti}, b::Union{Array{Tv, 1}, Array{Tv, 2}})\n\n\nSolve the distributed sparse linear system Ax = b, overwriting b with the solution. \n\nReturns b and the factor object which may be used to solve with different b or reuse parts of the factorization different values values for A.\n\n\n\n\n\n","category":"method"},{"location":"#SuperLUDIST.pgssvx!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ReplicatedSuperMatrix{Tv, Ti}, VecOrMat{Tv}}} where {Tv, Ti}","page":"Home","title":"SuperLUDIST.pgssvx!","text":"pgssvx!(A::ReplicatedSuperMatrix{Tv, Ti}, b::Union{Array{Tv, 1}, Array{Tv, 2}})\n\n\nSolve the replicated sparse linear system Ax = b, overwriting b with the solution. \n\nReturns b and the factor object which may be used to solve with different b or reuse parts of the factorization different values values for A.\n\n\n\n\n\n","category":"method"}]
}
